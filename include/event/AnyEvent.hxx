#pragma once

// xpp
#include <xpp/Event.hxx>

namespace xpp {

/// Wrapper around the base fields common to all X event structures.
class AnyEvent {
public: // functions

	explicit AnyEvent(const Event &ev) :
		m_any{ev.toAnyEvent()} {
	}

	/// The window the event is about, or occured on.
	/**
	 * \warning This field is not common to all events, this is kind of a
	 * glitch in the libX11 API.
	 *
	 * In some event types (CreateWindow, DestroyWindow, MapEvent,
	 * UnmapEvent, MapRequest) the field contains a WinID, but has a
	 * different semantic. In some event types (expose events) this is
	 * a Drawable, which has the same base type, but different meaning.
	 * The concrete event types override this accessor, if necessary, to
	 * reflect this.
	 *
	 * Therefore if the concrete event type does not store an actualy
	 * WinID here, a std::nullopt is returned.
	 **/
	std::optional<WinID> window() const {
		switch (type()) {
		default: return WinID{m_any.window};
		case EventType::GRAPHICS_EXPOSE:
		case EventType::NOEXPOSE:
			 // a Drawable is stored here instead
			 return {};
		}
	}

	EventType type() const { return EventType{m_any.type}; }

	/// If `true` then the event came from a SendEvent request (generated by another client).
	bool isFromSendEvent() const { return m_any.send_event == True; }

	/// Returns the raw pointer to the display this event was received on.
	/**
	 * You can use XDisplay::sameDisplay() to determine whether the event
	 * originated from a specific XDisplay instance.
	 **/
	const Display* display() const { return m_any.display; }

	/// Returns the #number of the last request processed by the server.
	unsigned long serial() const { return m_any.serial; }

protected: // functions

	explicit AnyEvent(const XAnyEvent &ev) :
		m_any{ev} {
	}

protected: // data
	const XAnyEvent &m_any;
};

} // end ns
